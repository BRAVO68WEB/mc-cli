use std::fs;
use std::io;
use std::path::Path;

#[derive(Debug, Clone)]
enum Line {
    Comment(String),
    Empty,
    Prop { key: String, value: String },
}

#[derive(Debug, Clone)]
pub struct ServerProperties {
    lines: Vec<Line>,
}

impl ServerProperties {
    /// Parse server.properties from string contents
    pub fn from_str(contents: &str) -> Result<Self, PropsError> {
        let mut lines = Vec::new();
        for raw in contents.split('\n') {
            let line = raw.to_string();
            if line.trim().is_empty() {
                lines.push(Line::Empty);
                continue;
            }
            if line.starts_with('#') {
                lines.push(Line::Comment(line));
                continue;
            }
            // key=value format; split on first '='
            if let Some(eq_idx) = line.find('=') {
                let key = line[..eq_idx].trim().to_string();
                let value = line[eq_idx + 1..].to_string(); // preserve spaces and formatting
                lines.push(Line::Prop { key, value });
            } else {
                // Treat unknown format as comment to preserve file
                lines.push(Line::Comment(line));
            }
        }
        Ok(Self { lines })
    }

    /// Read server.properties from a file path
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self, PropsError> {
        let contents = fs::read_to_string(path).map_err(PropsError::IoError)?;
        Self::from_str(&contents)
    }

    /// Get a property value by key (first occurrence)
    pub fn get(&self, key: &str) -> Option<String> {
        for l in &self.lines {
            if let Line::Prop { key: k, value } = l
                && k == key {
                    return Some(value.clone());
                }
        }
        None
    }

    /// Set or update a property value
    pub fn set(&mut self, key: impl Into<String>, value: impl Into<String>) {
        let k = key.into();
        let v = value.into();
        for l in &mut self.lines {
            if let Line::Prop { key: k0, value: v0 } = l
                && *k0 == k {
                    *v0 = v.clone();
                    return;
                }
        }
        self.lines.push(Line::Prop { key: k, value: v });
    }

    /// Remove the first occurrence of a property by key
    #[allow(dead_code)]
    pub fn remove(&mut self, key: &str) -> bool {
        if let Some(idx) = self
            .lines
            .iter()
            .position(|l| matches!(l, Line::Prop { key: k, .. } if k == key))
        {
            self.lines.remove(idx);
            true
        } else {
            false
        }
    }

    // Removed inherent to_string per clippy; Display is implemented below

    /// Save properties to a file path
    pub fn save<P: AsRef<Path>>(&self, path: P) -> Result<(), PropsError> {
        use std::fmt::Write as _;
        let mut s = String::new();
        // Render with Display implementation
        write!(&mut s, "{}", self).map_err(|e| PropsError::ParseError(e.to_string()))?;
        fs::write(path, s).map_err(PropsError::IoError)
    }
}

#[derive(Debug)]
pub enum PropsError {
    IoError(io::Error),
    ParseError(String),
}

impl std::fmt::Display for PropsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PropsError::IoError(e) => write!(f, "IO error: {}", e),
            PropsError::ParseError(e) => write!(f, "Parse error: {}", e),
        }
    }
}

impl std::error::Error for PropsError {}

impl std::fmt::Display for ServerProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for l in &self.lines {
            match l {
                Line::Comment(c) => {
                    writeln!(f, "{}", c)?;
                }
                Line::Empty => {
                    writeln!(f)?;
                }
                Line::Prop { key, value } => {
                    writeln!(f, "{}={}", key, value)?;
                }
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE: &str = r#"# Minecraft server properties
# Generated by mc-cli
max-tick-time=60000
view-distance=10
motd=A Minecraft Server initialized by mc-cli
"#;

    #[test]
    fn parse_basic_properties() {
        let props = ServerProperties::from_str(SAMPLE).unwrap();
        assert_eq!(props.get("max-tick-time").as_deref(), Some("60000"));
        assert_eq!(props.get("view-distance").as_deref(), Some("10"));
        assert_eq!(
            props.get("motd").as_deref(),
            Some("A Minecraft Server initialized by mc-cli")
        );
    }

    #[test]
    fn update_and_append_properties() {
        let mut props = ServerProperties::from_str(SAMPLE).unwrap();
        props.set("motd", "Hello World");
        props.set("difficulty", "hard");

        let s = props.to_string();
        assert!(s.contains("motd=Hello World"));
        assert!(s.contains("difficulty=hard"));
        // comments should persist
        assert!(s.contains("# Minecraft server properties"));
    }

    #[test]
    fn load_and_save_file() {
        // Prepare temp input/output files to avoid repo-relative paths
        let tmpdir = std::env::temp_dir();
        let input_path = tmpdir.join("mc-cli_server.properties.in");
        let output_path = tmpdir.join("mc-cli_server.properties.out");

        // Write SAMPLE to input and load from file
        std::fs::write(&input_path, SAMPLE).unwrap();
        let orig = ServerProperties::from_file(&input_path).unwrap();
        assert_eq!(orig.get("view-distance").as_deref(), Some("10"));

        // Modify and save to an output file
        let mut modified = orig.clone();
        modified.set("view-distance", "12");
        modified.set("pvp", "true");
        modified.save(&output_path).unwrap();

        let reloaded = ServerProperties::from_file(&output_path).unwrap();
        assert_eq!(reloaded.get("view-distance").as_deref(), Some("12"));
        assert_eq!(reloaded.get("pvp").as_deref(), Some("true"));
    }
}
