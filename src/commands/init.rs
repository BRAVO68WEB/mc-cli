use clap::{Arg, ArgAction, Command};
use std::path::PathBuf;

/// Build the init subcommand definition
pub fn command() -> Command {
    Command::new("init")
        .about("Initialize a new Minecraft project")
        .arg(
            Arg::new("name")
                .short('n')
                .long("name")
                .value_name("NAME")
                .help("Name of the project")
                .required(false)
                .default_value("my-minecraft-project")
        )
}

/// Execute the init subcommand
pub async fn execute(matches: &clap::ArgMatches) -> Result<(), Box<dyn std::error::Error>> {
    let project_name = matches.get_one::<String>("name").unwrap();
    println!("Initializing new Minecraft project: {}", project_name);

    // Fetch Fabric versions
    let fabric_versions: FabricVersion = fetch_fabric_versions().await?;
    println!("Using Fabric Versions:");
    println!("  Loader:    {}", fabric_versions.loader);
    println!("  Game:      {}", fabric_versions.game);
    println!("  Installer: {}", fabric_versions.installer);

    // create a mc.toml configuration file
    let config_content = format!(r#"
name = "{}"
[versions]
mc_version = "{}"
fabric_version = "{}"
mc_cli_version = "0.1.0"
"#,
        project_name,
        fabric_versions.game,
        fabric_versions.loader
    );
    let config_path = PathBuf::from("mc.toml");
    tokio::fs::write(&config_path, config_content).await?;
    println!("Created configuration file: {:?}", config_path);

    // Download the latest Fabric server JAR
    // curl -OJ https://meta.fabricmc.net/v2/versions/loader/1.21.10/0.17.3/1.1.0/server/jar
    let fabric_server_url = format!(
        "https://meta.fabricmc.net/v2/versions/loader/{}/{}/{}/server/jar",
        fabric_versions.game,
        fabric_versions.loader,
        fabric_versions.installer
    );
    let output_file = format!("fabric-server-{}-{}.jar", fabric_versions.game, fabric_versions.loader);
    println!("Downloading Fabric server JAR from: {}", fabric_server_url);
    let response = reqwest::get(&fabric_server_url).await?;
    let bytes = response.bytes().await?;
    tokio::fs::write(&output_file, &bytes).await?;
    println!("Downloaded Fabric server JAR to: {}", output_file);

    println!("Initialization complete.");

    // create eula.txt file
    let eula_content = "eula=true\n";
    let eula_path = PathBuf::from("eula.txt");
    tokio::fs::write(&eula_path, eula_content).await?;
    println!("Created EULA file: {:?}", eula_path);

    // create server.properties file
    let server_properties_content = r#"# Minecraft server properties
# Generated by mc-cli
max-tick-time=60000
view-distance=10
motd=A Minecraft Server initialized by mc-cli
"#;
    let server_properties_path = PathBuf::from("server.properties");
    tokio::fs::write(&server_properties_path, server_properties_content).await?;
    println!("Created server properties file: {:?}", server_properties_path);

    Ok(())
}

pub struct FabricVersion {
    pub loader: String,
    pub game: String,
    pub installer: String,
}
/// Fetch Fabric version information
async fn fetch_fabric_versions() -> Result<FabricVersion, Box<dyn std::error::Error>> {
    use crate::libs::fabric::FabricClient;

    let client = FabricClient::new()?;

    // Fetch latest stable versions
    let loader = client.get_latest_loader().await?;
    let game = client.get_latest_game().await?;
    let installer = client.get_latest_installer().await?;

    // latest versions variables
    let mut lv: String = String::new();
    let mut gv: String = String::new();
    let mut iv: String = String::new();

    if let Some(l) = loader {
        lv = l.version.clone();
    }
    if let Some(g) = game {
        gv = g.version.clone();
    }
    if let Some(i) = installer {
        iv = i.version.clone();
    }

    Ok(FabricVersion {
        loader: lv,
        game: gv,
        installer: iv,
    })
}